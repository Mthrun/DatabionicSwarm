{
    "collab_server" : "",
    "contents" : "ABCanalysis=function(Data,ABCcurvedata,PlotIt=FALSE){\n# abcres = ABCanalysis(Data=ABCcleanData(Data)$CleanedData)\n# divide the Data in 3 classes A, B,C\n# A==Data(Aind) : mit wenig aufwand viel ertrag! \n# B==Data(Bind) : Aufwand und ertrag halten sich die Waage\n# C==Data(Cind) : viel Aufwand, wenig Ertrag\n#\n# Grenzziehung AB: minimaler Abstand zum ideal [0,1]\n# Grenzziehung BC: \n# \n# INPUT\n# Data(1:n)                 Ungleichverteilung so dass ABC Analyse sinnvoll ist\n#\n# OPTIONAL\n# PlotIt                      if variable is used a plot is made, set with PlotIt=1,PlotIt=TRUE, PlotIt='On', etc\n# ABCcurvedata                Liste V aus ABCcurve()\n#\n# OUTPUT\n# Aind,Bind,Cind              so dass:\n#                             A==Data(Aind) : mit wenig aufwand viel ertrag! \n#                             B==Data(Bind) : Aufwand und ertrag halten sich die Waage\n#                             C==Data(Cind) : viel Aufwand, wenig Ertrag\n# smallestAData: Grenzziehung AB: minimaler Abstand zum ideal [0,1]\n# smallestBData: Grenzziehung BC: Steigung der ABC kurve == 1  \n#\n# AlimitIndInInte\\rpolation,BlimitIndInInterpolation    indices der ABC genzen in [p,ABC]\n# [p,ABC]                                              die interpolationskurve des ABC plots.\n# \n# A=c(Ax,Ay)              Pareto point, Minimum distance to (0,1) = minimal Unrealized potential == min in Effort und min in (1-\n# B=c(Bx,By)              BreakEven Point: dABC(Bx) == 1 \n# C=c(Cx,Cy)             Submarginal Point: Minimum distance to (Bx,1) \n# ABexchanged             bool, TRUEif Point A is the BreakEven and point B is the Pareto Point, 0 otherwise\n\n  \n# author: MT 11/2014\n#\n\n#Uses:\n# ABCcurve, im else-Fall: ABCanalysisPlot\nif(missing(Data)){\n  if(missing(ABCcurvedata)){stop('argument \"Data\" and ABCcurvedata are missing')}else{\n  Data=NULL #Dann muss ABCcurvedata vorhanden sein\n  }\n}\n  \nif(!PlotIt){#Wenn nicht geplottet wird muessen die Daten berechnet werden\n  if(missing(ABCcurvedata)){\n    # CleanData=1; # bedeutet die kleinen Yieldwerte, die in Summme <0.5% der Gesamtyield \n     ABCcurvedata = ABCcurve(Data)\n  } \n  \n  Effort=ABCcurvedata$Curve[,'Effort']\n  Yield=ABCcurvedata$Curve[,'Yield']\n\n#   Indizies=ABCcurvedata$DataInd\n#Distanz zum 0,1 Punkt ueber Euklid berechnet\n  curve=cbind(Effort,Yield)\n  distPareto=c()\n  point=t(as.matrix(c(0,1)))\n  for(i in 1:length(Effort)){\n    distPareto[i]=sum(abs(point-curve[i,])^2)\n  }\n  ParetoPointInd=which.min(distPareto) #First Minimun\n# Bestimme den AB Punkt auf der Spline Kurve  \n  ParetoPoint=curve[ParetoPointInd,]\n# Fuer den Punkt BC bestimme die Ableitung der Kurve \n\n#   n=length(Effort)\n#   Curvengleichung=splinefun(Effort,Yield) \n#   ableitung=Curvengleichung(1:n/n,1)\n\n   ableitung=ABCcurvedata$Slope[,'dABC']\n# Suche das Minimum zur Differenz Ableitung vordefiniete Steigung\n  BreakEvenInds=which.min(abs(ableitung - 1))  #Schraenkt B ein, Ableitung==1\n\n# Bestimme die Werte der Spline Kurve an dem BC Punkt \nBreakEvenInd=max(BreakEvenInds)# falls es mehr als 1 gibt nimm den rechtesten\n  BreakEvenPoint=curve[BreakEvenInd,] #Last\n  \nif(Effort[BreakEvenInd]<Effort[ParetoPointInd]){\n    ABexchanged=TRUE\n    JurenInd=BreakEvenInd\n    Bx=Effort[ParetoPointInd]\n   # By=Yield[BreakEvenInd]\n\tA=BreakEvenPoint\n\tB=ParetoPoint\n  }else{\n    JurenInd=ParetoPointInd\n    Bx=Effort[BreakEvenInd]\n    #By=Yield[ParetoPointInd]\n    ABexchanged=FALSE\n\tA=ParetoPoint\n\tB=BreakEvenPoint\n  }\n\n  distBx=c()\n  Juren=t(as.matrix(c(Bx,1)))\n  for(i in 1:length(Effort)){\n    distBx[i]=sum(abs(Juren-curve[i,])^2)\n  }\n  bgrenze=which.min(distBx) #First Minimun \n#print(curve[bgrenze[1],])\n  \nC=curve[bgrenze[1],]\n\n\n\n## Datenvektor in 3 Gruppen Teilen\n\nif(!is.null(Data)){ \n#Statt nach in Y-Werten suchen, suchen wir in x-Werten, da diese Eindeutig\n#y-Werte koennen dagegen in spezialfaellen mehrfach belegt sein\n    Indizies=order(Data,decreasing=TRUE)\n    rows=length(Data)\n    x=1:rows/rows\n# Vergleiche empirische Kurve mit generierten Ma? aus theoretischer Spline Kurve\n    Aindvor=which(x<A[1],arr.ind=TRUE)# Suche alle Indizes bis zur ABGrenze\n    ABind=which(x<C[1],arr.ind=TRUE) # Suche alle Indizes bis zur BCgrenze\n#Setzte in unsortierten Datenvektor die Indizes\n    Bind=Indizies[setdiff(ABind,Aindvor)] #Bindizes sind Differenz aus den beiden Zeilen davor\n    Aind=Indizies[Aindvor] \n    Cind=Indizies[which(x>C[1],arr.ind=TRUE)]\n\n# #Zuerst: Generiere empirische Kurven direkt aus den Daten  \n#        sorted=sort(na.last=T,Data,decreasing=TRUE)\n#        Indizies=order(Data,decreasing=TRUE)\n#        N=sum(Data)\n#        Anteil=sorted/N\n#        y=cumsum(Anteil)\n# # Vergleiche empirische Kurve mit generierten Ma? aus theoretischer Spline Kurve\n#     Aindvor=which(y<A[2],arr.ind=TRUE)# Suche alle Indizes bis zur ABGrenze\n#     ABind=which(y<C[2],arr.ind=TRUE) # Suche alle Indizes bis zur BCgrenze\n# #Setzte in unsortierten Datenvektor die Indizes\n#     Bind=Indizies[setdiff(ABind,Aindvor)] #Bindizes sind Differenz aus den beiden Zeilen davor\n#     Aind=Indizies[Aindvor] \n#     Cind=Indizies[which(y>C[2],arr.ind=TRUE)]\n}else{ #Keine empirischer Datensatz sondern vorgabe theoretischer Kurve\n  Bind=NULL\n  Cind=NULL\n  Aind=NULL\n  warning('No Data given: Calculating curve and points by given ABCcurvedata')\n}\n  return(list(Aind=Aind,Bind=Bind,Cind=Cind,ABexchanged=ABexchanged,A=A,B=B,C=C,smallestAData=Yield[JurenInd],smallestBData=Yield[bgrenze],AlimitIndInInterpolation=JurenInd,BlimitIndInInterpolation=bgrenze,p=Effort,ABC=Yield))\n  #Falls Plot erwuenscht\n  }else{ #Dann werden die Daten in ueber ABCanalysisPlot berechnet und ABCplot verwendet\n    if(missing(Data)|is.null(Data)){\n      abc=ABCanalysisPlot(ABCcurvedata=ABCcurvedata)$ABCanalysis  \n    }else{\n      abc=ABCanalysisPlot(Data)$ABCanalysis\n    }\n  }  \n}",
    "created" : 1467129849630.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2389996318",
    "id" : "C9A8D0D9",
    "lastKnownWriteTime" : 1467129962,
    "last_content_update" : 1467129962680,
    "path" : "D:/Subversion/PUB/dbt/ABCanalysis/R/ABCanalysis.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}