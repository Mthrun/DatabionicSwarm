{
    "collab_server" : "",
    "contents" : "Pswarm = pswarmCpp = function(DataOrDistance,PlotIt=F,Cls=NULL,Silent=T,Debug=FALSE,LC=c(NULL,NULL),method='euclidean',...){\n# bmus=pswarmCpp(DataOrDists,PlotIt=T,Cls)\n# Laesst den Pswarm Schwarmalgorithmus ueber einen Datensatz laufen\n# polar oriatated swarm\n#\n# INPUT\n# DataOrDistance[1:n,1:d]   distance matrix, the  matrix has to be symmetric, \n#                           if its not symetric data matrix is assumed and Dists=DistanceMatrix(data); \n#                           data matrix is array of data: n cases in rows, d variables in columns, matrix is not symmetric\n#\n# OPTIONAL\n# PlotIt                    bool, defaut=FALSE, if =TRUE: ClassPlot of every current Position of Databots will be made. At the end of pswarm Plots of sum(stress) will be mad\n# Cls                       vector, Klassifikation of Data if available, ClassPlots will be colorized\n#\n# Silent                    =FALSE: No print Output, =TRUE some print outs\n# Debug                     =TRUE: Debigging Modus, Slow with alot of prints\n# OUTPUT Liste V\n# V$BestMatchingUnits[1:n,1:3]        n by 2 matrix containing  X and Y coordinates of the n BestMatches for each databot including unique key\n#                           BestMatches need to be unique. Transformation from polar (R,phi) to kartesisch (x,y) is done automatically\n# V$Grid                    vector aus c(Lines,Columns)\n# V$Control                 Alle m?glichen Parameter, um nachzuvollziehen, wenn was schiefgeht\n#  \n# Autor: MT 01/2015\n# Nota: im debugging modus sollten relativ differenzen des payoffs angegeben werden statt festen werten\n  \n#############################\n## Not required anymore  \n  # LC                        Vector of Lines and Colums, specific:\n# Lines   Default=50, x-value determining the size of the map, i.e. how many open places for DataBots will be available  on the 2-dimensional grid\n#  \t\t\t\tBEWARE: must be divisible by two\n#\n# Columns Default=80, y-value  determining the size of the map, i.e. how many open places for DataBots will be available on the 2-dimensional grid\n#\t\t\t\t\tColumns>Lines.\n#\t\t\t\t\t\t                # BEWARE: If you choose hexagonal, Column number must be divisible by four \n#\n\n  DataOrDistance=checkInputDistancesOrData(DataOrDistance)\n  \n  if (missing(DataOrDistance)) {\n    stop('Distances are Missing.')\n  } else{\n    if (is.list(DataOrDistance)) {\n      stop('DataOrDistance is a list! It has to be a matrix.')\n    }\n    if (!is.matrix(DataOrDistance)) {\n      {\n        warning('DataOrDistance is not a matrix. Trying to circumvent...')\n        if (is.data.frame(DataOrDistance))\n          DataOrDistance = data.matrix(DataOrDistance)\n        else\n          DataOrDistance = as.matrix(DataOrDistance)\n      }\n    }\n  }\n  if (!Silent)\n    print('Operator: Setting options')\n  \n  QuadOrHexa = F #hesagonales Gitter => dichteste Kugelpackung\n  # if(PlotIt)\n  #   tryCatch({requireNamespace(\"plotrix\")},error=function(ex) {})#zum plotten\n  #\n  if (isSymmetric(DataOrDistance)) {\n    DataDists = DataOrDistance\n    AnzVar = ncol(DataOrDistance)\n    AnzData = nrow(DataOrDistance)\n  } else{\n    #!isSymmetric\n    warning('Distances are not in a symmetric matrix, Datamatrix is assumed and dist() ist called')\n\n    DataDists = as.matrix(parallelDist::parDist(DataOrDistance, method = method,...))\n\t\tAnzVar = ncol(DataDists)\n    AnzData = nrow(DataDists)\n  }# end if(isSymmetric(DataOrDists))\n\n  if (is.null(LC[1]))\n    LC = setGridSize(DataDists)\n  else{\n\tif(!is.vector(LC)) stop('LC has to be a vector')\n    if(is.list(LC)) stop('LC has to be a vector not a list')\n\tif(!is.numeric(LC)) stop('LC has to be numeric')\n  }\n  DBAnzahl = AnzData\n  if (is.null(Cls))\n    Cls = rep(1, DBAnzahl)\n  \n  Lines = LC[1]\n  Columns = LC[2]\n  if (Lines %% 2 != 0) {\n    stop('Lines has to be even')\n  }\n  if (Columns %% 4 != 0) {\n    stop('Columns has to be dividable by four')\n  }\n  #achtung unter umstaenden darf auch Lines==Columns nicht gelten, muss ich noch pruefen\n  # in setPolarGrid\n  if (Lines > Columns) {\n    stop('Number of Columns has to be higher than number of Lines')\n  }\n  if (Lines * Columns < DBAnzahl) {\n    stop('Map is too small for the Number of DataBots, please chose higher Lines and Columns')\n  }\n  Rmax = Lines / 2\n  \n  reldiffp=function(x,y){\n    if(x+y==0) return(0)\n    return(signif((y-x)/(0.5*(x+y)),2)*100)\n  }\n  \n  # Initialisierung von ben?tigten InputVariablen\n  ################################################################################################\n  # Mein Algorithmus\n  ################################################################################################\n  ListeDerPositionsSchablonen = setPolarGrid(\n    Lines = Lines,\n    Columns = Columns,\n    QuadOrHexa = QuadOrHexa,\n    PlotIt = F\n  )                     #Binary matrix of all free DataBotsPositions(=0), Positions of DataBots will be defined by 1\n  GridRadii = ListeDerPositionsSchablonen$GridRadii                     #Radii Matrix of all possible Positions of DataBots in Grid\n  GridAngle = ListeDerPositionsSchablonen$GridAngle                   #Angle Matrix of all possible Positions of DataBots in Grid\n  AllallowedDBPosR0 = ListeDerPositionsSchablonen$AllallowedDBPosR0         #Radius-Matrix in polar coordinates respecting origin (0,0) of all allowed DataBots Positions in one jump\n  AllallowedDBPosPhi0 = ListeDerPositionsSchablonen$AllallowedDBPosPhi0#Angle-Matrix in polar coordinates respecting origin (0,0) of all allowed DataBots Positions in one jump\n  ## Geht schief wenn LC zu klein\n  init = sample(x = Lines * Columns,\n                replace = F,\n                size = DBAnzahl)\n  binary = matrix(0, nrow = Lines, ncol = Columns)\n  dballind = which(binary == 0, arr.ind = T)\n  DataBotsPos = dballind[init, ]\n  #richtig cooler Trick\n  AllDataBotsPos = DataBotsPos[, 1] + 1i * DataBotsPos[, 2]\n  Nullpunkt = which(AllallowedDBPosR0 == 0, arr.ind = T)\n  \n  if (QuadOrHexa) {\n    #Bei quadratischen Gitter ist minimaler Radius groesser 3 noetig\n    Rmin = setRmin(AllallowedDBPosR0, Lines, Columns, DBAnzahl, p = 0.05)\n  } else{\n    # !QuadOrHexa\n    #Rmin=1\n    Rmin = setRmin(AllallowedDBPosR0, Lines, Columns, DBAnzahl, p = 0.05)\n  }# end if QuadOrHexa\n  #pp=seq(1,100,4)/100 #FuerAnzahl gleichzeitig springender DataBots\n  m = (0.5 - 0.05) / (Rmax - Rmin)\n  b = 0.5 - m * Rmax\n  pp = m * 1:Rmax + b\n  #pp=(1:Rmax)/Rmax-Rmin/Rmax+1/DBAnzahl\n  #pp=pmax(0.05,pp)\n  # pp=pmin(0.5,pp)\n  # pp=pmax((1:Rmax)/Rmax-Rmin/Rmax,0.15)\n  jumpthreshold = 0\n  stressverlauf = c()\n  if (!Silent)\n    print('Operator: Starting algorithm')\n  \n  fokussiertlaufind = 1\n  rvec = seq(from = Rmax, by = -1, to = Rmin)\n  stress = Inf\n  alpha = Rmax * 0.01\n  \n  RadiusPositionsschablone = ListeDerPositionsSchablonen$AllallowedDBPosR0\n  IndPossibleDBPosR = findPossiblePositionsCsingle(RadiusPositionsschablone, Rmax, alpha, Lines)\n  \n  eppocheradiusreduziert = c()\n  OutputDistance = rDistanceToroidCsingle(\n    Re(AllDataBotsPos),\n    Im(AllDataBotsPos),\n    ListeDerPositionsSchablonen$AllallowedDBPosR0,\n    Lines,\n    Columns,\n    as.vector(Nullpunkt)\n  )\n  Nachbahrschaftsfunktion = 1 - OutputDistance ^ 2 / (pi * Rmax ^ 2)\n  Nachbahrschaftsfunktion[Nachbahrschaftsfunktion < 0] = 0\n  N = sum(Nachbahrschaftsfunktion)\n  StressConstAditiv = sum(Nachbahrschaftsfunktion * DataDists) / N\n\n  dummy=0;\n  numberOfSteps=length(rvec)\n\tif(Silent){\n\t\tprogress = txtProgressBar(min = dummy, max = numberOfSteps+1, style = 3)\n\t}else{\n\t  ProzentualeZeitfolge=round(sort((rvec-Rmin)/(Rmax-Rmin),decreasing=F)*100,0)\n\t  ProzentualeZeitfolge[numberOfSteps]=99\n\t}\n  for (Radius in rvec) {\n\t\tdummy=dummy+1\n    if (!Silent){  \n      print(paste0('Operator: ', ProzentualeZeitfolge[dummy],'% calculated.'))\n      #print(paste0('Operator: Current focus: ', Radius))\n\t\t\t#setTxtProgressBar\n    }else{\n\t\t\t progressm = setTxtProgressBar(progress, dummy)\n\t\t}\n      \n    \n    Eppoche = 1\n    Jumping = TRUE\n    limit = ceiling(1 / pp[Radius]) # Ab welcher Eppoche wird Abbruchbedingung geprueft\n    steigungsverlaufind = 20#limit #wieviele zurueckliegende eppochen werden maximal geprueft\n    if (PlotIt) {\n      bmu = getCartesianCoordinates(AllDataBotsPos,\n                                    GridRadius = GridRadii,\n                                    GridAngle,\n                                    QuadOrHexa = QuadOrHexa)\n      string = paste0('Radius ', Radius, ', Eppoche ', Eppoche)\n      plotSwarm(bmu, Cls, main = string)\n    } #end if\n    #Zeitfaktor: Je naeher DataBots springen, desto schneller riechen sie erneut entspricht, weniger DBs springen pro Eppoche\n    nBots = round(pp[Radius] * DBAnzahl)\n    #nBots=round(0.05*DBAnzahl)#s. Fast and reliable ESOM learning\n    List = PswarmCurrentRadiusC2botsPositive(\n      AllDataBotsPos,\n      Radius,\n      DataDists,\n      IndPossibleDBPosR,\n      RadiusPositionsschablone,\n      pp,\n      Nullpunkt,\n      Lines,\n      Columns,\n      nBots,\n      limit,\n      steigungsverlaufind,\n      StressConstAditiv,\n      Debug\n    )\n    AllDataBotsPos = List$AllDataBotsPos\n    stressverlauf = c(stressverlauf, List$stressverlauf)\n    eppocheradiusreduziert = c(eppocheradiusreduziert, List$fokussiertlaufind)\n    if (!Silent) {\n      print(paste0('Operator: ', tail(eppocheradiusreduziert, 1), '.iteration'))\n      print(\n        paste0(\n          'Operator: weak Nash equilibrium found. Paypoff maximized with ',\n          reldiffp(List$stressverlauf[1],tail(List$stressverlauf, 1)),\n          ' %'\n        )\n      )\n    }\n  } #end for rvec\n  if (!Silent){  \n    print(paste0('Operator: 100 % calculated.'))\n  }else{\n    progressm = setTxtProgressBar(progress, dummy+1)\n    close(progress) \n  }\n\n  bmu = getCartesianCoordinates(AllDataBotsPos,\n                                GridRadius = GridRadii,\n                                GridAngle,\n                                QuadOrHexa = QuadOrHexa)\n  #Possible Minor Rounding error\n  if(max(bmu[,1])>Lines)\n    Lines=Lines+1\n  if(max(bmu[,2])>Columns)\n    Columns=Columns+1\n  \n  return(list(\n    ProjectedPoints = bmu,\n    LC = c(Lines, Columns),\n    Control = list(\n      stressverlauf = stressverlauf,\n      eppocheradiusreduziert = eppocheradiusreduziert,\n      LetzteEppocheStress = stress\n    )\n  ))\n}\n",
    "created" : 1525275812469.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3086911246",
    "id" : "7EC4C58",
    "lastKnownWriteTime" : 1525276439,
    "last_content_update" : 1525276439561,
    "path" : "D:/Subversion/PUB/dbt/DataBionicSwarm/R/pswarmCpp.R",
    "project_path" : "R/pswarmCpp.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}