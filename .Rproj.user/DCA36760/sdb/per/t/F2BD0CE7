{
    "collab_server" : "",
    "contents" : "DBSclustering=function(k,DataOrDistance,BestMatches,LC,StructureType=TRUE,PlotIt=FALSE,method='euclidean',...){\n#Cls=DBSclustering(k,Data,BestMatches,LC,StructureType=TRUE,PlotIt=F,method='euclidean')\n# automated Clustering approach of the DataBionicSwarm with abstact U distances\n# INPUT\n# k                   number of classes, how many to you see in the 3d landscape?\n# DataOrDistance      Matrix of Data or Distance that will be used. One DataPoint per row\n# BestMatches         Array with positions of Bestmatches=ProjectedPoints\n# LC\n# OPTIONAL  \n# StructureType           compact structure of clusters assumed, =FALSE: connected structure of clusters assumed\n# PlotIt              Plots Dendrogramm\n# method              do not change \n# OUTPUT \n# Cls                 vector with selected classes of the bestmatches\n#  \n# author: MT 06/16 \n#  \n#  NOTE: das ist eine eigene Idee: Nehme die Distantz in LoetschUltsch2014 definiert und stecke sie in\n#\t\tDistanz=ShortestGraphPaths -> Cluster sind immer in sich geschlossen in 2D\n#\t\t\t\t\t\t\t-> Politische Karte irrelevant -> Nahteil: Falls Projektion Fehler hat (Punke des einen Clusters innerhalb des anderen Clusters)\n#\t\t\t\t\t\t\t-> Hat Clusterung fehler und CLusterung ist nichtmehr dichte basiert\n# Alus 2016 IDEE ueber die Distanz ist in AUstarDist.R implementiert\n  #requireRpackage('deldir')\n  #requireRpackage('geometry')\n  DataOrDistance=checkInputDistancesOrData(DataOrDistance)\n  \n  if (isSymmetric(DataOrDistance)) {\n    InputD = DataOrDistance\n    rnames=1:nrow(DataOrDistance)\n  } else{\n    if(rownames(Data)!=0)\n      rnames=rownames(Data)\n    else\n      rnames=1:nrow(Data)\n      InputD = as.matrix(parallelDist::parDist(DataOrDistance, method = method,...))\n  }# end if(isSymmetric(DataOrDists))\n  \n GabrielGraph=FALSE #gabriel graph immer schlechter...\n  GOutput=Delaunay4Points(BestMatches, Grid = LC, IsToroid=T,PlotIt=F,Gabriel=GabrielGraph)\n    \n    Dist=ShortestGraphPathsC(GOutput,InputD)\n  if(StructureType){\n    pDist=as.dist(Dist)\n    hc <- hclust(pDist,method=\"ward.D\")\n    m=\"Compact DBS clustering\"\n  }else{\n    ind=which(GOutput==0,arr.ind=T)\n    Dist2=Dist*GOutput\n    Dist2[ind]=max(Dist)*2\n    pDist=as.dist(Dist2)\n    hc <- hclust(pDist,method=\"single\")\n    m=\"Connected DBS clustering\"\n  }\n  if(PlotIt){\n    x=as.dendrogram(hc)\n    plot(x, main=m,xlab=\"No. of Data Points N\", ylab=\"Distance\",sub=\" \",leaflab =\"none\")\n    axis(1,col=\"black\",las=1)\n  }\n  \n  Cls=cutree(hc,k)\n\n  counter = 0\n  bool = T\n  NumberOfClassesSet = k\n  while (counter < 0.05 * length(Cls)) {\n    counter = counter + 1\n    uniqueClasses <- sort(na.last = T, unique(Cls))\n    numberOfClasses <- length(uniqueClasses)\n    countPerClass <- rep(0, numberOfClasses)\n    for (i in 1:numberOfClasses) {\n      inClassI <-\n        sum(Cls == uniqueClasses[i]) # counts all occurances of uniqueClass[i] in cls\n      countPerClass[i] = inClassI\n    }\n    \n    if (max(countPerClass) > 0.95 * length(Cls)) {\n      k = k + 1\n      Cls = cutree(hc, k)\n      uniqueClasses <- sort(na.last = T, unique(Cls))\n      numberOfClasses <- length(uniqueClasses)\n      countPerClass <- rep(0, numberOfClasses)\n      for (i in 1:numberOfClasses) {\n        inClassI <-\n          sum(Cls == uniqueClasses[i]) # counts all occurances of uniqueClass[i] in cls\n        countPerClass[i] = inClassI\n      }\n      ind = order(countPerClass, decreasing = F, na.last = T)\n      n = numberOfClasses - NumberOfClassesSet\n      for (l in 1:n) {\n        indc = which(Cls == uniqueClasses[ind[l]])\n        Cls[indc] = 99\n      }\n    } else{\n      bool = FALSE\n    }\n    if (!bool)\n      break\n    # print(counter)\n  }\n  names(Cls)=rnames\n  return(Cls)\n}",
    "created" : 1525275464450.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3423624899",
    "id" : "F2BD0CE7",
    "lastKnownWriteTime" : 1525275522,
    "last_content_update" : 1525275522953,
    "path" : "D:/Subversion/PUB/dbt/DataBionicSwarm/R/DBSclustering.R",
    "project_path" : "R/DBSclustering.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}